<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="Chemputer Blog"><meta property="og:type" content="article"><meta property="og:image" content="https://chemistwang.github.io//img/home-bg.jpg"><meta property="twitter:image" content="https://chemistwang.github.io//img/home-bg.jpg"><meta name=title content="Build Your Own React (译文)"><meta property="og:title" content="Build Your Own React (译文)"><meta property="twitter:title" content="Build Your Own React (译文)"><meta name=description content="从零到一构建自己的React"><meta property="og:description" content="从零到一构建自己的React"><meta property="twitter:description" content="从零到一构建自己的React"><meta property="twitter:card" content="summary"><meta name=keyword content="汪洋龙, wangyanglong, Wangyanglong, 汪洋龙的博客, Wangyanglong Blog, 博客, 个人网站, 互联网, Web, Javascript, React"><link rel="shortcut icon" href=/img/favicon.ico><title>Build Your Own React (译文) | 汪洋龙的博客 | Wangyanglong Blog</title><link rel=canonical href=/post/translate/build-your-own-react/><link rel=stylesheet href=/css/bootstrap.min.css><link rel=stylesheet href=/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=/css/zanshang.css><link href=https://cdn.jsdelivr.net/gh/FortAwesome/Font-Awesome@5.15.1/css/all.css rel=stylesheet type=text/css><script src=/js/jquery.min.js></script>
<script src=/js/bootstrap.min.js></script>
<script src=/js/hux-blog.min.js></script></head><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=/>Chemputer Blog</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=/>All Posts</a></li><li><a href=/categories/es6>es6</a></li><li><a href=/categories/react>react</a></li><li><a href=/categories/tech>tech</a></li><li><a href=/categories/threejs>threejs</a></li><li><a href=/archive/>ARCHIVE</a></li><li><a href=/notes/>NOTES</a></li><li><a href=/about/>ABOUT</a></li><li><a href=/search><i class="fa fa-search"></i></a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(/img/react-bg.jpg)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags><a class=tag href=/tags/%E8%AF%91%E6%96%87 title=译文>译文</a></div><h1>Build Your Own React (译文)</h1><h2 class=subheading>「源码阅读」第一层：掌握术语、基本实现思路</h2><span class=meta>Posted by
汪洋龙
on
Wednesday, September 1, 2021</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><blockquote><p>参考资料:
<a href=https://pomb.us/build-your-own-react/>build-your-own-react</a></p></blockquote><h1 id=构建自己的-react>构建自己的 React</h1><p><strong>⚠️【注】因本人水平有限，部分语句使用意译。会根据水平提升及时修正完善🧐</strong></p><p><em>Rodrigo Pombo November 13, 2019</em></p><p>我们准备一步一步重写 <code>React</code>。下面的架构来自 <code>React</code> 源码，但把所有的优化和不必要的功能省略掉了。</p><p>如果你读过我之前的一篇帖子 <a href=https://engineering.hexacta.com/didact-learning-how-react-works-by-building-it-from-scratch-51007984e5c5><code>build your own React</code></a>，跟上一篇不同之处在于这一篇基于 <code>React16.8</code>，我们可以使用 <code>hooks</code>并且抛弃掉类组件代码</p><p>你可以在 <a href=https://github.com/pomber/didact><code>这里</code></a> 找到实现的代码仓库，在 <a href="https://www.youtube.com/watch?v=8Kc2REHdwnQ&amp;feature=youtu.be&amp;ab_channel=GrUSP"><code>这里</code></a> 看到相关视频</p><p>从零开始，我们会一步一步把这些加到我们的<code>React</code>中</p><ul><li>第一步：<code>createElement</code> 函数</li><li>第二步：<code>render</code> 函数</li><li>第三步：<code>concurrent</code> 模式</li><li>第四步：<code>Fibers</code></li><li>第五步：<code>Render</code> 和 <code>Commit</code> 阶段</li><li>第六步：<code>Reconcilation</code></li><li>第七步：<code>Function</code> 组件</li><li>第八步：<code>Hooks</code></li></ul><h2 id=前言>前言</h2><p>开始之前，我们回顾一些基本概念。如果你已经知道 <code>React</code>, <code>JSX</code> 和 <code>DOM</code> 元素如何运行，那么可以跳过。</p><p>我们用 <code>3</code> 行代码就可以启用一个 <code>React App</code>。</p><p>第一步: 定义一个 <code>React element</code></p><p>第二步: 从 <code>DOM</code> 获取一个节点</p><p>第三步：在 <code>container</code> 中渲染 <code>React element</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#ff79c6>const</span> element <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>&lt;</span>h1 title<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;foo&#34;</span><span style=color:#ff79c6>&gt;</span>Hello<span style=color:#ff79c6>&lt;</span>/h1&gt;
</span></span><span style=display:flex><span><span style=color:#ff79c6>const</span> container <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>document</span>.getElementById(<span style=color:#f1fa8c>&#34;root&#34;</span>)
</span></span><span style=display:flex><span>ReactDOM.render(element, container)
</span></span></code></pre></div><p><strong>让我们移除所有的React代码，用原生的JavaScript代替</strong></p><hr><p>第一行我们用 <code>JSX</code> 定义了元素，但这不是有效的 <code>Javascript</code>，所以为了用原生<code>JS</code>代替，我们需要把他变成有效的<code>JS</code></p><p><code>JSX</code> 是通过像 <code>Babel</code> 这样的构建工具转换成 <code>JS</code>。这种转化通常来说比较简单：调用 <code>createElement</code> 方法，把 <code>标签名</code>、<code>属性</code> 和它的 <code>子元素</code> 作为参数传入。</p><hr><p><code>React.createElement</code> 根据参数创建了一个对象。除了校验之外，这就是它做的全部了。所以可以安全替换掉。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#ff79c6>const</span> element <span style=color:#ff79c6>=</span> React.createElement(
</span></span><span style=display:flex><span>  <span style=color:#f1fa8c>&#34;h1&#34;</span>, 
</span></span><span style=display:flex><span>  { title<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;foo&#34;</span> }, 
</span></span><span style=display:flex><span>  <span style=color:#f1fa8c>&#34;Hello&#34;</span>
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span><span style=color:#6272a4>// const container = document.getElementById(&#34;root&#34;)
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ReactDOM.render(element, container)
</span></span></span></code></pre></div><p>这就是一个元素真正的样子，一个对象包含两个属性 <code>type</code> 和 <code>props</code>（其实有<a href=https://github.com/facebook/react/blob/f4cc45ce962adc9f307690e1d5cfa28a288418eb/packages/react/src/ReactElement.js#L111>很多</a>，我们只关心它俩）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#ff79c6>const</span> element <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>  type<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;h1&#34;</span>,
</span></span><span style=display:flex><span>  props<span style=color:#ff79c6>:</span> {
</span></span><span style=display:flex><span>    title<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;foo&#34;</span>,
</span></span><span style=display:flex><span>    children<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;Hello&#34;</span>,
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#6272a4>// const container = document.getElementById(&#34;root&#34;)
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ReactDOM.render(element, container)
</span></span></span></code></pre></div><p><code>type</code> 定义了我们想要创建什么类型的 <code>DOM</code> 节点，就是当你想要创建一个 <code>HTML</code> 元素的时候，传入 <code>document.createElement</code> 方法的 <code>标签名</code>。它也可以是一个函数，不过我们会在 <a href=#%E7%AC%AC%E4%B8%83%E6%AD%A5function%E7%BB%84%E4%BB%B6><strong>第七步</strong></a> 说明。</p><p><code>props</code> 是另一个对象，它包含了所有来自 <code>JSX</code> 的各项属性。它还有一个特殊的属性：<code>children</code>。</p><p><code>children</code> 在当前这个例子里是个 <code>string</code>，但多数情况是一个包含多个元素的 <code>array</code>。这也是为什么说元素也是树 🌲。</p><hr><p>另外一处需要替换的代码是 <code>ReactDOM.render</code>。</p><p><code>render</code> 表示 <code>React</code> 作用在哪个 <code>DOM</code> 上，那我们用自己的方式实现更新。</p><hr><p>首先我们用元素的 <code>type</code> 创建一个<code>节点</code>，当前例子就是 <code>h1</code>。</p><p>然后我们把所有属性放在这个 <code>节点</code> 里。当前只有 <code>title</code>。</p><blockquote><p>为了避免混淆，我用 <code>element</code> 代表 <code>React</code> 元素，用 <code>node</code> 代表 <code>DOM</code> 元素。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#ff79c6>const</span> element <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>  type<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;h1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// props: {
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    title<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;foo&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// children: &#34;Hello&#34;,
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  },
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#6272a4>// const container = document.getElementById(&#34;root&#34;)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>const</span> node <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>document</span>.createElement(element.type);
</span></span><span style=display:flex><span>node[<span style=color:#f1fa8c>&#34;title&#34;</span>] <span style=color:#ff79c6>=</span> element.props.title;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// const text = document.createTextNode(&#34;&#34;);
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// text[&#34;nodeValue&#34;] = element.props.children;
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// node.appendChild(text);
</span></span></span></code></pre></div><hr><p>然后为子元素创建节点。我们只有一个 <code>string</code> 作为子元素，那么就创建一个 <code>text node</code></p><p>为了在后续步骤中用同一种方法处理所有元素，我们用 <code>textNode</code> 而没用<code>innerText</code>。</p><p>注意一下，就像设置 <code>h1</code> 的 <code>title</code> 属性一样，我们用同样的方法设置 <code>nodeValue</code>，就像这个字符串有了属性一样 <code>props: {nodeValue: 'hello'}</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#ff79c6>const</span> element <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// type: &#34;h1&#34;,
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>// props: {
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>//   title: &#34;foo&#34;,
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    children<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;Hello&#34;</span>,
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#6272a4>// const container = document.getElementById(&#34;root&#34;)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// const node = document.createElement(element.type);
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// node[&#34;title&#34;] = element.props.title;
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>const</span> text <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>document</span>.createTextNode(<span style=color:#f1fa8c>&#34;&#34;</span>);
</span></span><span style=display:flex><span>text[<span style=color:#f1fa8c>&#34;nodeValue&#34;</span>] <span style=color:#ff79c6>=</span> element.props.children;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// node.appendChild(text);
</span></span></span></code></pre></div><hr><p>最后面把 <code>textNode</code> 放在 <code>h1</code> 中，然后把 <code>h1</code> 放到 <code>container</code> 里面。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#6272a4>// const element = {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   type: &#34;h1&#34;,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   props: {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     title: &#34;foo&#34;,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     children: &#34;Hello&#34;,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   },
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// };
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span><span style=color:#ff79c6>const</span> container <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>document</span>.getElementById(<span style=color:#f1fa8c>&#34;root&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// const node = document.createElement(element.type);
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// node[&#34;title&#34;] = element.props.title;
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// const text = document.createTextNode(&#34;&#34;);
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// text[&#34;nodeValue&#34;] = element.props.children;
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span>node.appendChild(text);
</span></span><span style=display:flex><span>container.apendChild(node)
</span></span></code></pre></div><hr><p>这下就和刚才一样了，区别是没有用 <code>React</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#ff79c6>const</span> element <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>  type<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;h1&#34;</span>,
</span></span><span style=display:flex><span>  props<span style=color:#ff79c6>:</span> {
</span></span><span style=display:flex><span>    title<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;foo&#34;</span>,
</span></span><span style=display:flex><span>    children<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;Hello&#34;</span>,
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#ff79c6>const</span> container <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>document</span>.getElementById(<span style=color:#f1fa8c>&#34;root&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>const</span> node <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>document</span>.createElement(element.type);
</span></span><span style=display:flex><span>node[<span style=color:#f1fa8c>&#34;title&#34;</span>] <span style=color:#ff79c6>=</span> element.props.title;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>const</span> text <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>document</span>.createTextNode(<span style=color:#f1fa8c>&#34;&#34;</span>);
</span></span><span style=display:flex><span>text[<span style=color:#f1fa8c>&#34;nodeValue&#34;</span>] <span style=color:#ff79c6>=</span> element.props.children;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>node.appendChild(text);
</span></span><span style=display:flex><span>container.apendChild(node)
</span></span></code></pre></div><hr><h2 id=第一步createelement-函数>第一步：<code>createElement</code> 函数</h2><p>我们从另一个 <code>app</code> 重新开始。这次用自己实现的 <code>React</code>。</p><p>先从实现 <code>createElement</code> 开始。</p><p>让我们把 <code>JSX</code> 转换为 <code>JS</code>，这样可以看到 <code>createElement</code>的调用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#ff79c6>const</span> element <span style=color:#ff79c6>=</span> (
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>&lt;</span>div id<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;foo&#34;</span><span style=color:#ff79c6>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&lt;</span>a<span style=color:#ff79c6>&gt;</span>bar<span style=color:#ff79c6>&lt;</span>/a&gt;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&lt;</span>b <span style=color:#ff79c6>/&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>&lt;</span>/div&gt;
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span><span style=color:#ff79c6>const</span> container <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>document</span>.getElementById(<span style=color:#f1fa8c>&#34;root&#34;</span>);
</span></span><span style=display:flex><span>ReactDOM.render(element, container);
</span></span></code></pre></div><hr><p>正如<code>上一步</code>所看到的，一个 <code>element</code> 是一个有 <code>type</code> 和 <code>props</code> 的对象。我们的函数只需要做一件事：就是创建这个对象。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#ff79c6>const</span> element <span style=color:#ff79c6>=</span> React.createElement(
</span></span><span style=display:flex><span>  <span style=color:#f1fa8c>&#34;div&#34;</span>,
</span></span><span style=display:flex><span>  { id<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;foo&#34;</span> },
</span></span><span style=display:flex><span>  React.createElement(<span style=color:#f1fa8c>&#34;a&#34;</span>, <span style=color:#ff79c6>null</span>, <span style=color:#f1fa8c>&#34;bar&#34;</span>),
</span></span><span style=display:flex><span>  React.createElement(<span style=color:#f1fa8c>&#34;b&#34;</span>)
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span><span style=color:#6272a4>// const container = document.getElementById(&#34;root&#34;);
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ReactDOM.render(element, container);
</span></span></span></code></pre></div><hr><p>我们对 <code>props</code> 使用 <code>对象扩展运算符</code>，对 <code>children</code> 用 <code>rest参数语法</code>，这样的话 <code>children</code> 属性就会一直是一个 <code>array</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> createElement(type, props, ...children) {
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> {
</span></span><span style=display:flex><span>    type,
</span></span><span style=display:flex><span>    props<span style=color:#ff79c6>:</span> {
</span></span><span style=display:flex><span>      ...props,
</span></span><span style=display:flex><span>      children,
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>例如，<code>createElement('div')</code> 返回</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f1fa8c>&#34;type&#34;</span><span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;div&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f1fa8c>&#34;props&#34;</span><span style=color:#ff79c6>:</span> { <span style=color:#f1fa8c>&#34;children&#34;</span><span style=color:#ff79c6>:</span> [] }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>createElement("div", null, a)</code>返回</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f1fa8c>&#34;type&#34;</span><span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;div&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f1fa8c>&#34;props&#34;</span><span style=color:#ff79c6>:</span> { <span style=color:#f1fa8c>&#34;children&#34;</span><span style=color:#ff79c6>:</span> [a] }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>createElement("div", null, a, b)</code>返回</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f1fa8c>&#34;type&#34;</span><span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;div&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f1fa8c>&#34;props&#34;</span><span style=color:#ff79c6>:</span> { <span style=color:#f1fa8c>&#34;children&#34;</span><span style=color:#ff79c6>:</span> [a, b] }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><p><code>children</code> 数组可能也会包含 <code>string</code> 或者 <code>numbers</code> 这样的原始值，所以我们对这类不是对象的值创建一个特殊类型：<code>TEXT_ELEMENT</code></p><blockquote><p>当它们不是 <code>children</code>时，<code>React</code> 并不会包裹原始值或者创建一个空数组。这么做是因为可以简化代码，对于我们的实现库来说，简洁会更重要。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#6272a4>// function createElement(type, props, ...children) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   return {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     type,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     props: {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       ...props,
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>      children<span style=color:#ff79c6>:</span> children.map((child) =&gt;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>typeof</span> child <span style=color:#ff79c6>===</span> <span style=color:#f1fa8c>&#34;object&#34;</span> 
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>?</span> child
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>:</span> createTextElement(child)
</span></span><span style=display:flex><span>      ),
</span></span><span style=display:flex><span><span style=color:#6272a4>//     },
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   };
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// }
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> createTextElement(text) {
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> {
</span></span><span style=display:flex><span>    type<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;TEXT_ELEMENT&#34;</span>,
</span></span><span style=display:flex><span>    props<span style=color:#ff79c6>:</span> {
</span></span><span style=display:flex><span>      nodeValue<span style=color:#ff79c6>:</span> text,
</span></span><span style=display:flex><span>      children<span style=color:#ff79c6>:</span> [],
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><p>我们仍然用了 <code>React</code> 的 <code>createElement</code></p><p>为了替换的目的，我们给自己的实现库起一个名字。</p><p>我们需要一个听上去像 <code>React</code> 的名字，同时也能达到 <code>didactic</code> 目的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#6272a4>// const element = React.createElement(
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   &#34;div&#34;,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   { id: &#34;foo&#34; },
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  React.createElement(<span style=color:#f1fa8c>&#34;a&#34;</span>, <span style=color:#ff79c6>null</span>, <span style=color:#f1fa8c>&#34;bar&#34;</span>),
</span></span><span style=display:flex><span>  React.createElement(<span style=color:#f1fa8c>&#34;b&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#6272a4>// )
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>...
</span></span></code></pre></div><hr><p>就叫 <code>Didact</code> 吧。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#ff79c6>const</span> Didact <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>  createElement,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#ff79c6>const</span> element <span style=color:#ff79c6>=</span> Didact.createElement(
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// &#34;div&#34;,
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>// { id: &#34;foo&#34; },
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  Didact.createElement(<span style=color:#f1fa8c>&#34;a&#34;</span>, <span style=color:#ff79c6>null</span>, <span style=color:#f1fa8c>&#34;bar&#34;</span>),
</span></span><span style=display:flex><span>  Didact.createElement(<span style=color:#f1fa8c>&#34;b&#34;</span>)
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>但我们还想在这用 <code>JSX</code> 语法，怎么告诉 <code>babel</code> 是要用 <code>Didact</code> 的 <code>createElement</code>呢？</p><hr><p>如果我们有一个像这样的注释，当 <code>babel</code> 编译的时候就会用我们定义的函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#6272a4>/** @jsx Didact.createElement */</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>const</span> element <span style=color:#ff79c6>=</span> (
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>&lt;</span>div id<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;foo&#34;</span><span style=color:#ff79c6>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&lt;</span>a<span style=color:#ff79c6>&gt;</span>bar<span style=color:#ff79c6>&lt;</span>/a&gt;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&lt;</span>b <span style=color:#ff79c6>/&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>&lt;</span>/div&gt;
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><h2 id=第二步render函数>第二步：<code>render</code>函数</h2><p>接下来，我们需要实现一个自己的 <code>ReactDOM.render</code> 函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>...
</span></span><span style=display:flex><span>ReactDOM.render(element, container);
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><hr><p>现在只考虑如何添加，后面再去实现更新和删除。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> render(element, container) {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// TODO create dom nodes
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>const</span> Didact <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// createElement,
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  render
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/** @jsx Didact.createElement */</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>const</span> element <span style=color:#ff79c6>=</span> (
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>&lt;</span>div id<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;foo&#34;</span><span style=color:#ff79c6>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&lt;</span>a<span style=color:#ff79c6>&gt;</span>bar<span style=color:#ff79c6>&lt;</span>/a&gt;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&lt;</span>b <span style=color:#ff79c6>/&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>&lt;</span>/div&gt;
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// const container = document.getElementById(&#39;root&#39;);
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>Didact.render(element, container);
</span></span></code></pre></div><hr><p>用 <code>element</code> 的 <code>type</code> 属性生成 <code>DOM</code>，然后将 <code>node</code> 追加到 <code>container</code>中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> render(element, container) {
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>const</span> dom <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>document</span>.createElement(element.type)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  container.appendChild(dom)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// const Didact = {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   createElement,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   render
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// }
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/** @jsx Didact.createElement */</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// const element = (
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   &lt;div id=&#34;foo&#34;&gt;
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     &lt;a&gt;bar&lt;/a&gt;
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     &lt;b /&gt;
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   &lt;/div&gt;
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// );
</span></span></span></code></pre></div><hr><p>对每个 <code>child</code> 递归就好了</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> render(element, container) {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// const dom = document.createElement(element.type)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  
</span></span><span style=display:flex><span>  ​element.props.children.forEach(child =&gt;
</span></span><span style=display:flex><span>      render(child, dom)
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// container.appendChild(dom)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// const Didact = {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   createElement,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   render
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// }
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/** @jsx Didact.createElement */</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// const element = (
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   &lt;div id=&#34;foo&#34;&gt;
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     &lt;a&gt;bar&lt;/a&gt;
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     &lt;b /&gt;
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   &lt;/div&gt;
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// );
</span></span></span></code></pre></div><hr><p>我们需要处理下 <code>text</code> 元素，如果类型是 <code>TEXT_ELEMENT</code>，我们就创建一个 <code>text node</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> render(element, container) {
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>const</span> dom <span style=color:#ff79c6>=</span>
</span></span><span style=display:flex><span>    element.type <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#34;TEXT_ELEMENT&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>?</span> <span style=color:#8be9fd;font-style:italic>document</span>.createTextNode(<span style=color:#f1fa8c>&#34;&#34;</span>)
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>:</span> <span style=color:#8be9fd;font-style:italic>document</span>.createElement(element.type)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>//   ​element.props.children.forEach(child =&gt;
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>//       render(child, dom)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>//   )
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>// container.appendChild(dom)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><hr><p>最后加上 <code>element</code> 的属性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> render(element, container) {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// const dom =
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>//   element.type == &#34;TEXT_ELEMENT&#34;
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>//     ? document.createTextNode(&#34;&#34;)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>//     : document.createElement(element.type)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>const</span> isProperty <span style=color:#ff79c6>=</span> key =&gt; key <span style=color:#ff79c6>!==</span> <span style=color:#f1fa8c>&#34;children&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>Object</span>.keys(element.props)
</span></span><span style=display:flex><span>      .filter(isProperty)
</span></span><span style=display:flex><span>      .forEach(name =&gt; {
</span></span><span style=display:flex><span>        dom[name] <span style=color:#ff79c6>=</span> element.props[name]
</span></span><span style=display:flex><span>      })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// ​element.props.children.forEach(child =&gt;
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>//     render(child, dom)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>// )
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>// container.appendChild(dom)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><hr><p>现在，我们有了一个自己的实现库，可以把 <code>JSX</code> 渲染到 <code>DOM</code> 上 。</p><p>在 <a href=https://codesandbox.io/s/didact-2-k6rbj><code>codesandbox</code></a> 👈 试试</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> createElement(type, props, ...children) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> {
</span></span><span style=display:flex><span>        type,
</span></span><span style=display:flex><span>        props<span style=color:#ff79c6>:</span> {
</span></span><span style=display:flex><span>            ...props,
</span></span><span style=display:flex><span>            children<span style=color:#ff79c6>:</span> children.map(child =&gt;
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>typeof</span> child <span style=color:#ff79c6>===</span> <span style=color:#f1fa8c>&#34;object&#34;</span> <span style=color:#ff79c6>?</span> child <span style=color:#ff79c6>:</span> createTextElement(child)
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> createTextElement(text) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> {
</span></span><span style=display:flex><span>        type<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;TEXT_ELEMENT&#34;</span>,
</span></span><span style=display:flex><span>        props<span style=color:#ff79c6>:</span> {
</span></span><span style=display:flex><span>            nodeValue<span style=color:#ff79c6>:</span> text,
</span></span><span style=display:flex><span>            children<span style=color:#ff79c6>:</span> []
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> render(element, container) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> dom <span style=color:#ff79c6>=</span>
</span></span><span style=display:flex><span>        element.type <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#34;TEXT_ELEMENT&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>?</span> <span style=color:#8be9fd;font-style:italic>document</span>.createTextNode(<span style=color:#f1fa8c>&#34;&#34;</span>)
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>:</span> <span style=color:#8be9fd;font-style:italic>document</span>.createElement(element.type);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> isProperty <span style=color:#ff79c6>=</span> key =&gt; key <span style=color:#ff79c6>!==</span> <span style=color:#f1fa8c>&#34;children&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>Object</span>.keys(element.props)
</span></span><span style=display:flex><span>        .filter(isProperty)
</span></span><span style=display:flex><span>        .forEach(name =&gt; {
</span></span><span style=display:flex><span>            dom[name] <span style=color:#ff79c6>=</span> element.props[name];
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    element.props.children.forEach(child =&gt; render(child, dom));
</span></span><span style=display:flex><span>    container.appendChild(dom);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>const</span> Didact <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>    createElement,
</span></span><span style=display:flex><span>    render
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/** @jsx Didact.createElement */</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>const</span> element <span style=color:#ff79c6>=</span> (
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&lt;</span>div style<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;background: salmon&#34;</span><span style=color:#ff79c6>&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>&lt;</span>h1<span style=color:#ff79c6>&gt;</span>Hello World<span style=color:#ff79c6>&lt;</span>/h1&gt;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>&lt;</span>h2 style<span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;text-align:right&#34;</span><span style=color:#ff79c6>&gt;</span>from Didact<span style=color:#ff79c6>&lt;</span>/h2&gt;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&lt;</span>/div&gt;
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span><span style=color:#ff79c6>const</span> container <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>document</span>.getElementById(<span style=color:#f1fa8c>&#34;root&#34;</span>);
</span></span><span style=display:flex><span>Didact.render(element, container);
</span></span></code></pre></div><h2 id=第三步concurrent-模式>第三步：<code>Concurrent</code> 模式</h2><p>但&mldr;在我们添加更多的代码之前需要进行一次重构。</p><hr><p>因为在 <code>递归</code> 的调用上存在一个问题。</p><p>一旦程序开始，在渲染整个 <code>element</code> 树之前是不会停下来的。如果 <code>element</code> 树过于庞大，它可能会长时间阻塞主线程。</p><p>如果浏览器需要优先处理，诸如用户输入或者保持丝滑的动画效果，就不得不等待渲染结束。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> render(element, container) {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// const dom =
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>//     element.type == &#34;TEXT_ELEMENT&#34;
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>//         ? document.createTextNode(&#34;&#34;)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>//         : document.createElement(element.type);
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// const isProperty = key =&gt; key !== &#34;children&#34;;
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>// Object.keys(element.props)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>//     .filter(isProperty)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>//     .forEach(name =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>//         dom[name] = element.props[name];
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>//     });
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span>  element.props.children.forEach(child =&gt; 
</span></span><span style=display:flex><span>    render(child, dom)
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// container.appendChild(dom);
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><hr><p>现在我们准备把工作流切分成一个个小的单元，当每一个单元结束后，如果有其他需要完成的事情，就让浏览器打断渲染。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>let</span> nextUnitOfWork <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> workLoop(deadline) {
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>let</span> shouldYield <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>while</span> (nextUnitOfWork <span style=color:#ff79c6>&amp;&amp;</span> <span style=color:#ff79c6>!</span>shouldYield) {
</span></span><span style=display:flex><span>    nextUnitOfWork <span style=color:#ff79c6>=</span> performUnitOfWork(
</span></span><span style=display:flex><span>      nextUnitOfWork
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    shouldYield <span style=color:#ff79c6>=</span> deadline.timeRemaining() <span style=color:#ff79c6>&lt;</span> <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  requestIdleCallback(workLoop)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>​
</span></span><span style=display:flex><span>requestIdleCallback(workLoop)
</span></span><span style=display:flex><span>​
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> performUnitOfWork(nextUnitOfWork) {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// TODO
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><hr><p>用 <code>requestIdleCallback</code> 去实现循环。你可以把 <code>requestIdleCallback</code> 当成 <code>setTimeout</code>，区别在于我们不需要手动调用，当浏览器主线程空闲的时候它就会执行。</p><blockquote><p>React 现在<a href=https://github.com/facebook/react/issues/11171#issuecomment-417349573>不再用 <code>requestIdleCallback</code></a>，而是 <a href=https://github.com/facebook/react/tree/main/packages/scheduler><code>schedule package</code></a>。但对于当前案例，原理是一样的。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#6272a4>// let nextUnitOfWork = null
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> workLoop(deadline) {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// let shouldYield = false
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>// while (nextUnitOfWork &amp;&amp; !shouldYield) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>//   nextUnitOfWork = performUnitOfWork(
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>//     nextUnitOfWork
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>//   )
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>//   shouldYield = deadline.timeRemaining() &lt; 1
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>// }
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  requestIdleCallback(workLoop)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>​
</span></span><span style=display:flex><span>requestIdleCallback(workLoop)
</span></span><span style=display:flex><span>​
</span></span><span style=display:flex><span><span style=color:#6272a4>// function performUnitOfWork(nextUnitOfWork) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>// TODO
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// }
</span></span></span></code></pre></div><hr><p><code>requestIdleCallback</code>有一个 <code>deadline</code> 参数，可以用于检查浏览器重新掌握控制权之前我们还有多少时间。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#6272a4>// let nextUnitOfWork = null
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> workLoop(deadline) {
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>let</span> shouldYield <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>while</span> (nextUnitOfWork <span style=color:#ff79c6>&amp;&amp;</span> <span style=color:#ff79c6>!</span>shouldYield) {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>//   nextUnitOfWork = performUnitOfWork(
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>//     nextUnitOfWork
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>//   )
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    shouldYield <span style=color:#ff79c6>=</span> deadline.timeRemaining() <span style=color:#ff79c6>&lt;</span> <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// }
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>// requestIdleCallback(workLoop)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span><span style=display:flex><span>​
</span></span><span style=display:flex><span><span style=color:#6272a4>// requestIdleCallback(workLoop)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>​
</span></span><span style=display:flex><span><span style=color:#6272a4>// function performUnitOfWork(nextUnitOfWork) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>// TODO
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// }
</span></span></span></code></pre></div><blockquote><p>截止2019年11月，concurrent 模式不再稳定。稳定版本的循环更像是这样</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#ff79c6>while</span> (nextUnitOfWork) {    
</span></span><span style=display:flex><span>  nextUnitOfWork <span style=color:#ff79c6>=</span> performUnitOfWork(   
</span></span><span style=display:flex><span>    nextUnitOfWork  
</span></span><span style=display:flex><span>  ) 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><p>在开始循环之前，我们需要设置下第一次 <code>unit</code>，然后实现一个 <code>performUnitOfWork</code> 函数。这个函数不仅要执行当前单元的 <code>work</code>，也需要返回下一个单元的 <code>work</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>let</span> nextUnitOfWork <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> workLoop(deadline) {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// let shouldYield = false
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>// while (nextUnitOfWork &amp;&amp; !shouldYield) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    nextUnitOfWork <span style=color:#ff79c6>=</span> performUnitOfWork(
</span></span><span style=display:flex><span>      nextUnitOfWork
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// shouldYield = deadline.timeRemaining() &lt; 1
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>// }
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>// requestIdleCallback(workLoop)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span><span style=display:flex><span>​
</span></span><span style=display:flex><span><span style=color:#6272a4>// requestIdleCallback(workLoop)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>​
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> performUnitOfWork(nextUnitOfWork) {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// TODO
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><h2 id=第四步fibers>第四步：<code>Fibers</code></h2><p>为了组织这些单元的 <code>work</code>，我们需要一个数据结构：<code>fiber</code> 树 🌲。</p><p>每一个 <code>element</code> 都会对应一个<code>fiber</code>,每一个 <code>fiber</code> 也会对应一个 <code>work</code>。</p><p>用一个例子 🌰 说明下。</p><p>假设我们想渲染这样一棵 <code>element</code> 树：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>Didact.render(
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>&lt;</span>div<span style=color:#ff79c6>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&lt;</span>h1<span style=color:#ff79c6>&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>&lt;</span>p <span style=color:#ff79c6>/&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>&lt;</span>a <span style=color:#ff79c6>/&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&lt;</span>/h1&gt;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>&lt;</span>h2 <span style=color:#ff79c6>/&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>&lt;</span>/div&gt;,
</span></span><span style=display:flex><span>  container
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>在 <code>render</code> 中，我们会创建 <code>root fiber</code>，并将它设为 <code>nextUnitOfWork</code>。剩下的工作交给 <code>performUnitOfWork</code> 函数执行。每一个 <code>fiber</code> 都要做 <code>3</code> 件事：</p><ol><li><code>DOM</code> 中添加 <code>element</code></li><li>为每一个 <code>element</code> 的 <code>children</code> 创建 <code>fiber</code></li><li>选择下一个单元的 <code>work</code></li></ol><hr><p>这种数据结构的其中一个目的是方便找到 <code>work</code> 的下一个单元，这就是为什么每一个 <code>fiber</code> 都需要关联它的 <code>first child</code>, <code>next sibling</code> 和 <code>parent</code></p><p><img src=/img/build-your-own-react-1.jpg alt=Fiber数结构></p><hr><p>当我们在一个 <code>fiber</code> 完成 <code>work</code>时，如果它有 <code>child</code>，将会进行下一个单元的 <code>work</code></p><p>用我们的这个例子来说，<code>div fiber</code> 之后就到了 <code>h1 fiber</code></p><hr><p>如果当前 <code>fiber</code> 没有 <code>child</code>，就到了它的 <code>sibling</code></p><p>举个例子，<code>p</code> 没有 <code>child</code>，所以在它完成之后就轮到 <code>a fiber</code></p><hr><p>如果既没有 <code>child</code> 也没有 <code>sibling</code>，就会去找 <code>uncle</code>，也就是 <code>parent sibling</code>。比如这个例子中的 <code>a</code> 和 <code>h2</code>。</p><p>如果 <code>parent</code> 没有 <code>sibling</code>，就继续向上查找，直到有 <code>sibling</code> 或者干脆到 <code>root</code>。至此，我们就认为在这次 <code>render</code> 中完成了所有的 <code>work</code>。</p><hr><p>现在带入到代码中。</p><hr><p>首先，把 <code>render</code> 函数中的代码移除。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> render(element, container) {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// TODO set next unit of work
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><hr><p>我们保留部分创建 <code>DOM</code> 节点的代码，稍后会用到。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> createDom(fiber) {
</span></span><span style=display:flex><span><span style=color:#6272a4>//   const dom =
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     fiber.type == &#34;TEXT_ELEMENT&#34;
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       ? document.createTextNode(&#34;&#34;)
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       : document.createElement(fiber.type)
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ​
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   const isProperty = key =&gt; key !== &#34;children&#34;
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   Object.keys(fiber.props)
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     .filter(isProperty)
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     .forEach(name =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       dom[name] = fiber.props[name]
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     })
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ​
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   return dom
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><hr><p>在 <code>render</code> 函数中，我们给 <code>fiber</code> 树的 <code>root</code> 设置 <code>nextUnitOfWork</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> render(element, container) {
</span></span><span style=display:flex><span>  nextUnitOfWork <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>    dom<span style=color:#ff79c6>:</span> container,
</span></span><span style=display:flex><span>    props<span style=color:#ff79c6>:</span> {
</span></span><span style=display:flex><span>      children<span style=color:#ff79c6>:</span> [element]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>let</span> nextUnitOfWork <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span>
</span></span></code></pre></div><hr><p>然后，当浏览器准备好了，它会执行 <code>workLoop</code>，我们将在 <code>root</code> 开始</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#6272a4>// let nextUnitOfWork = null
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>​
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> workLoop(deadline) {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// let shouldYield = false
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>// while (nextUnitOfWork &amp;&amp; !shouldYield) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    nextUnitOfWork <span style=color:#ff79c6>=</span> performUnitOfWork(
</span></span><span style=display:flex><span>      nextUnitOfWork
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// shouldYield = deadline.timeRemaining() &lt; 1
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  }
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// requestIdleCallback(workLoop)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span><span style=display:flex><span>​
</span></span><span style=display:flex><span><span style=color:#6272a4>// requestIdleCallback(workLoop)
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>​
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> performUnitOfWork(fiber) {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// TODO add dom node
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>// TODO create new fibers
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>// TODO return next unit of work
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><hr><p>首先，我们创建一个新的 <code>node</code> 并把它追加到 <code>DOM</code> 中。</p><p>并在 <code>fiber.dom</code> 属性中追踪 <code>DOM</code> 节点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#6272a4>// function performUnitOfWork(fiber) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>fiber.dom) {
</span></span><span style=display:flex><span>    fiber.dom <span style=color:#ff79c6>=</span> createDom(fiber)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>​
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> (fiber.parent) {
</span></span><span style=display:flex><span>    fiber.parent.dom.appendChild(fiber.dom)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// TODO create new fibers
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#6272a4>// TODO return next unit of work
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><hr><p>然后对每个 <code>child</code> 创建一个新的 <code>fiber</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#6272a4>// function performUnitOfWork(fiber) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   if (!fiber.dom) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     fiber.dom = createDom(fiber)
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   }
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ​
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   if (fiber.parent) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     fiber.parent.dom.appendChild(fiber.dom)
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   }
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#ff79c6>const</span> elements <span style=color:#ff79c6>=</span> fiber.props.children
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>let</span> index <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>let</span> prevSibling <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span>
</span></span><span style=display:flex><span>​
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>while</span> (index <span style=color:#ff79c6>&lt;</span> elements.length) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> element <span style=color:#ff79c6>=</span> elements[index]
</span></span><span style=display:flex><span>​
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> newFiber <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>      type<span style=color:#ff79c6>:</span> element.type,
</span></span><span style=display:flex><span>      props<span style=color:#ff79c6>:</span> element.props,
</span></span><span style=display:flex><span>      parent<span style=color:#ff79c6>:</span> fiber,
</span></span><span style=display:flex><span>      dom<span style=color:#ff79c6>:</span> <span style=color:#ff79c6>null</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// TODO return next unit of work
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><hr><p>然后根据情况，我们把它作为 <code>child</code> 或者是 <code>subling</code> 来加到 <code>fiber</code> 树中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#6272a4>// function performUnitOfWork(fiber) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   if (!fiber.dom) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     fiber.dom = createDom(fiber)
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   }
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ​
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   if (fiber.parent) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     fiber.parent.dom.appendChild(fiber.dom)
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   }
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   const elements = fiber.props.children
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   let index = 0
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   let prevSibling = null
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ​
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   while (index &lt; elements.length) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     const element = elements[index]
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ​
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     const newFiber = {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       type: element.type,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       props: element.props,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       parent: fiber,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       dom: null,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     }
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (index <span style=color:#ff79c6>===</span> <span style=color:#bd93f9>0</span>) {
</span></span><span style=display:flex><span>      fiber.child <span style=color:#ff79c6>=</span> newFiber
</span></span><span style=display:flex><span>    } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>      prevSibling.sibling <span style=color:#ff79c6>=</span> newFiber
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>​
</span></span><span style=display:flex><span>    prevSibling <span style=color:#ff79c6>=</span> newFiber
</span></span><span style=display:flex><span>    index<span style=color:#ff79c6>++</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// TODO return next unit of work
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><hr><p>最后我们去找下一个单元的 <code>work</code>。先找 <code>child</code>，然后是 <code>sibling</code>，再是 <code>uncle</code>，以此类推</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#6272a4>// function performUnitOfWork(fiber) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   if (!fiber.dom) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     fiber.dom = createDom(fiber)
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   }
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ​
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   if (fiber.parent) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     fiber.parent.dom.appendChild(fiber.dom)
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   }
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   const elements = fiber.props.children
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   let index = 0
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   let prevSibling = null
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ​
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   while (index &lt; elements.length) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     const element = elements[index]
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ​
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     const newFiber = {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       type: element.type,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       props: element.props,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       parent: fiber,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       dom: null,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     }
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span><span style=color:#6272a4>//     if (index === 0) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       fiber.child = newFiber
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     } else {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       prevSibling.sibling = newFiber
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     }
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ​
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     prevSibling = newFiber
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     index++
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span><span style=color:#6272a4>//   }
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#ff79c6>if</span> (fiber.child) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> fiber.child
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>let</span> nextFiber <span style=color:#ff79c6>=</span> fiber
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>while</span> (nextFiber) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (nextFiber.sibling) {
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>return</span> nextFiber.sibling
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    nextFiber <span style=color:#ff79c6>=</span> nextFiber.parent
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><p>这就是我们全部的 <code>performUnitOfWork</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> performUnitOfWork(fiber) {
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>fiber.dom) {
</span></span><span style=display:flex><span>    fiber.dom <span style=color:#ff79c6>=</span> createDom(fiber)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>​
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> (fiber.parent) {
</span></span><span style=display:flex><span>    fiber.parent.dom.appendChild(fiber.dom)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>​
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>const</span> elements <span style=color:#ff79c6>=</span> fiber.props.children
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>let</span> index <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>let</span> prevSibling <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span>
</span></span><span style=display:flex><span>​
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>while</span> (index <span style=color:#ff79c6>&lt;</span> elements.length) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> element <span style=color:#ff79c6>=</span> elements[index]
</span></span><span style=display:flex><span>​
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>const</span> newFiber <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>      type<span style=color:#ff79c6>:</span> element.type,
</span></span><span style=display:flex><span>      props<span style=color:#ff79c6>:</span> element.props,
</span></span><span style=display:flex><span>      parent<span style=color:#ff79c6>:</span> fiber,
</span></span><span style=display:flex><span>      dom<span style=color:#ff79c6>:</span> <span style=color:#ff79c6>null</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>​
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (index <span style=color:#ff79c6>===</span> <span style=color:#bd93f9>0</span>) {
</span></span><span style=display:flex><span>      fiber.child <span style=color:#ff79c6>=</span> newFiber
</span></span><span style=display:flex><span>    } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>      prevSibling.sibling <span style=color:#ff79c6>=</span> newFiber
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>​
</span></span><span style=display:flex><span>    prevSibling <span style=color:#ff79c6>=</span> newFiber
</span></span><span style=display:flex><span>    index<span style=color:#ff79c6>++</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>​
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> (fiber.child) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> fiber.child
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#8be9fd;font-style:italic>let</span> nextFiber <span style=color:#ff79c6>=</span> fiber
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>while</span> (nextFiber) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> (nextFiber.sibling) {
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>return</span> nextFiber.sibling
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    nextFiber <span style=color:#ff79c6>=</span> nextFiber.parent
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>​
</span></span></code></pre></div><h2 id=第五步render和-commit-阶段>第五步：<code>Render</code>和 <code>Commit</code> 阶段</h2><p>现在又有另一个问题。</p><p>每次作用于一个 <code>element</code> 时，我们都会给 <code>DOM</code> 添加一个新的 <code>node</code>。记住，在我们渲染整棵树之前，浏览器可以随时打断我们的 <code>work</code>。在这种情况下，用户会看到一个没有完成的 <code>UI</code>。这并不是我们想要的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> performUnitOfWork(fiber) {
</span></span><span style=display:flex><span><span style=color:#6272a4>//   if (!fiber.dom) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     fiber.dom = createDom(fiber)
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   }
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>​
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> (fiber.parent) {
</span></span><span style=display:flex><span>    fiber.parent.dom.appendChild(fiber.dom)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>​
</span></span><span style=display:flex><span><span style=color:#6272a4>//   const elements = fiber.props.children
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   let index = 0
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   let prevSibling = null
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ​
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   while (index &lt; elements.length) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     const element = elements[index]
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ​
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     const newFiber = {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       type: element.type,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       props: element.props,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       parent: fiber,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       dom: null,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     }
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ​
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     if (index === 0) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       fiber.child = newFiber
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     } else {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       prevSibling.sibling = newFiber
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     }
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ​
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     prevSibling = newFiber
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     index++
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   }
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ​
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   if (fiber.child) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     return fiber.child
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   }
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   let nextFiber = fiber
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   while (nextFiber) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     if (nextFiber.sibling) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       return nextFiber.sibling
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     }
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     nextFiber = nextFiber.parent
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   }
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// }
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>​
</span></span></code></pre></div><hr><p>所以我们需要从这儿把影响 <code>DOM</code> 的这部分移除掉。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> performUnitOfWork(fiber) {
</span></span><span style=display:flex><span><span style=color:#6272a4>//   if (!fiber.dom) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     fiber.dom = createDom(fiber)
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   }
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>​
</span></span><span style=display:flex><span><span style=color:#6272a4>//  &gt;
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>​
</span></span><span style=display:flex><span><span style=color:#6272a4>//   const elements = fiber.props.children
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   let index = 0
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   let prevSibling = null
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ​
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   while (index &lt; elements.length) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     const element = elements[index]
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ​
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     const newFiber = {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       type: element.type,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       props: element.props,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       parent: fiber,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       dom: null,
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     }
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ​
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     if (index === 0) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       fiber.child = newFiber
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     } else {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       prevSibling.sibling = newFiber
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     }
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ​
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     prevSibling = newFiber
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     index++
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   }
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// ​
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   if (fiber.child) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     return fiber.child
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   }
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   let nextFiber = fiber
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   while (nextFiber) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     if (nextFiber.sibling) {
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//       return nextFiber.sibling
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     }
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//     nextFiber = nextFiber.parent
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//   }
</span></span></span><span style=display:flex><span><span style=color:#6272a4>// }
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>​
</span></span></code></pre></div><hr><p>反而，我们要继续追踪这个 <code>fiber</code> 树的 <code>root</code>。我们把它叫进行中的 <code>work</code> 或者是 <code>wipRoot</code>。</p><blockquote><p>【译者注】：<code>wip</code> 是 <code>work in process</code> 的缩写</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> render(element, container) {
</span></span><span style=display:flex><span>  wipRoot <span style=color:#ff79c6>=</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  nextUnitOfWork <span style=color:#ff79c6>=</span> wipRoot;
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// ...
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>  <span style=color:#8be9fd;font-style:italic>let</span> wipRoot <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><p>一旦我们完成了所有的 <code>work</code> (能确保的原因是不会有下一个单元的 <code>work</code>) 再将整棵 <code>fiber</code> 树提交给这个 <code>DOM</code></p><hr><p>我们把它放在 <code>commitRoot</code> 函数中。然后我们给 <code>dom</code> 递归追加所有节点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> commitRoot() {
</span></span><span style=display:flex><span>  commitWork(wipRoot.child)
</span></span><span style=display:flex><span>  wipRoot <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>null</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> commitWork(fiber) {
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>if</span> (<span style=color:#ff79c6>!</span>fiber) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>const</span> domParent <span style=color:#ff79c6>=</span> fiber.parent.dom
</span></span><span style=display:flex><span>  domParent.appendChild(fiber.dom)
</span></span><span style=display:flex><span>  commitWork(fiber.child)
</span></span><span style=display:flex><span>  commitWork(fiber.sibling)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=第六步reconciliation>第六步：<code>Reconciliation</code></h2><p>至此，我们完成了在 <code>DOM</code> 中添加的操作，那么更新和删除呢？</p><p>这就我们准备要做的事情，</p><p>我们需要拿到 <code>render</code> 函数接收到的 <code>elements</code>，去和上一次的提交做对比。</p><hr><p>所以在提交给 <code>DOM</code> 之后需要保存一份引用，把它称为 <code>currentRoot</code>。</p><p>同样我们给每个 <code>fiber</code> 添加一个 <code>alternate</code> 属性。这个属性指向 <code>old fiber</code>，就是我们上一次 <code>commit</code> 阶段提交的 <code>fiber</code>。</p><hr><p>现在我们把创建 <code>new fiber</code> 的代码从 <code>performUnitOfWork</code> 中提炼出来&mldr;</p><p>&mldr;放到一个叫 <code>reconcileChildren</code> 的新函数中。</p><hr><p>在这儿我们准备把 <code>old fiber</code> 和 <code>new element</code> 做一个 <code>reconcile</code>。</p><hr><p>我们同时递归 <code>old fiber</code> 的子元素（<code>wipFiber</code> 的 <code>alternate</code> 属性），这个数组里面的元素就是我们想要 <code>reconcile</code> 的。</p><p>如果我们同时忽略数组中需要迭代的模版和链表，那在这个循环语句中我们剩下最多的是：<code>oldFiber</code> 和 <code>element</code>。</p><p><strong><code>element</code> 是我们想要渲染给 <code>DOM</code> 的， <code>oldFiber</code> 是我们最后一次渲染的。</strong></p><p>我们需要比较他们，如果其中有变化，我们需要发起一次申请。</p><p>用 <code>type</code> 去比较他们：</p><ul><li><p>如果 <code>old fiber</code> 和 <code>new element</code> 有相同的 <code>type</code>，那么我们保留 <code>DOM</code> 节点只需要更新它的 <code>props</code></p></li><li><p>如果 <code>type</code> 不一样并且是一个 <code>new element</code>，意味着需要创建一个新的 <code>DOM</code> 节点</p></li><li><p>如果 <code>type</code> 不一样并且是一个 <code>old fiber</code>，我们需要移除这个节点</p></li></ul><blockquote><p>这里 React 用了 <code>keys</code> 属性，对于 <code>reconciliation</code> 来说会更好。例如，在一个数组中检测子元素的位置变化。</p></blockquote><hr><p>当 <code>old fiber</code> 和 <code>element</code> 有相同的 <code>type</code> 时，我们创建一个 <code>new fiber</code> 保存来自 <code>old fiber</code> 的 <code>DOM</code> 节点和来自 <code>element</code> 的 <code>props</code></p><p>我们也在这个 <code>fiber</code> 中加了一个新属性：<code>effectTag</code>。这个将在 <code>commit</code> 阶段用到。</p><hr><p>对于这个情况来说， <code>element</code> 需要一个新的 <code>DOM</code> 节点，我们用 <code>PLACEMENT</code> 来标记这个 <code>new fiber</code>。</p><hr><p>那对于这个情况来说，我们需要删除这个 <code>node</code>，也不需要 <code>new fiber</code>，所以在 <code>old fiber</code> 标记一个 <code>DELETION</code>。</p><p>当提交 <code>fiber</code> 树的时候，我们放在正在 <code>work</code> 的 <code>root</code> 去做，因为它不存在 <code>old fiber</code></p><hr><p>所以我们需要一个数组去秩序跟踪想要移除的节点。</p><hr><p>然后，当我们把变化提交给 <code>DOM</code> 时，我们也从那个数组用这些 <code>fiber</code>。</p><hr><p>现在，我们修改一下 <code>commitWork</code> 函数去处理这些新的 <code>effectTags</code>。</p><hr><p>如果是 <code>PLACEMENT</code>，就像往常一样，从父级的 <code>fiber</code> 追加 <code>DOM</code> 节点。</p><hr><p>如果是 <code>DELETION</code>，相反，移除这个子节点。</p><hr><p>如果是 <code>UPDATE</code>，我们在已存在的 <code>DOM</code> 节点上去更新变化的 <code>prop</code>。</p><hr><p>我们在 <code>updateDOM</code> 这个函数中去处理。</p><hr><p>对比 <code>new fiber</code> 和 <code>old fiber</code>。移除没有的 <code>prop</code>，设置新的或者有变化的 <code>prop</code>。</p><hr><p>其中一个特殊的 <code>prop</code> 需要更新是 <code>event listener</code>，所以如果这个属性以 <code>on</code> 开头，就特殊处理。</p><hr><p>如果 <code>event</code> 处理器有变化，移除。</p><hr><p>然后添加一个新的处理器。</p><hr><p>在 <a href=https://codesandbox.io/s/didact-6-96533><code>codesandbox</code></a> 👈 尝试一下带有 <code>reconciliation</code> 的版本。</p><h2 id=第七步function组件>第七步：<code>Function</code>组件</h2><p>下面需要添加的是为了支持 <code>Function</code> 组件。</p><p>我们在这个例子上做一些修改。用这个简单的 <code>function</code> 组件，去返回一个 <code>h1</code> 元素。</p><p>注意如果我们把 <code>JSX</code> 转化为 <code>JS</code>，会是这样：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>function</span> App(props) {
</span></span><span style=display:flex><span>  <span style=color:#ff79c6>return</span> Didact.createElement(
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;h1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#f1fa8c>&#34;Hi&#34;</span>,
</span></span><span style=display:flex><span>    props.name
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>const</span> element <span style=color:#ff79c6>=</span> Didact.createElement(App,
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  name<span style=color:#ff79c6>:</span> <span style=color:#f1fa8c>&#34;foo&#34;</span>
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p><code>Function</code> 组件有 <code>2</code> 个不同之处：</p><ul><li><p>来自 <code>Function</code> 组件的 <code>fiber</code> 没有 <code>DOM</code> 节点。</p></li><li><p><code>children</code> 是从函数来的而不是直接从 <code>props</code> 获取。</p></li></ul><hr><p>那我们检查下 <code>fiber</code> 的 <code>type</code> 是否是一个函数，根据这个去实现不同的更新函数。</p><p><code>updateHostComponent</code> 我们不变。</p><hr><p>在 <code>updateFunctionComponent</code> 我们去获取 <code>children</code>。</p><p>在我们这个例子中，<code>fiber.type</code> 是 <code>App</code> 函数，运行之后返回 <code>h1</code> 元素。</p><p>然后，一旦我们获取到 <code>children</code>，<code>reconciliation</code> 就一样了，不需要修改任何东西。</p><hr><p><code>commitWork</code> 函数需要修改一下。</p><p>现在我们有了不带 <code>DOM</code> 节点的 <code>fiber</code>，需要有 <code>2</code> 个地方变一下。</p><hr><p>第一个，为了找到一个 <code>DOM</code> 的父级，我们需要向上查找，直到一个 <code>fiber</code> 包含一个 <code>DOM</code> 节点。</p><hr><p>当我们移除一个节点时，也需要找到带有 <code>DOM</code> 节点的子元素。</p><h2 id=第八步hooks>第八步：<code>Hooks</code></h2><p>到最后一步了，现在我们有了 <code>Function</code> 组件。
添加一下 <code>state</code>。</p><hr><p>把我们的例子变成经典的计数组件。每次点击，它的状态都会增加。</p><p>注意现在我们用 <code>Didact.useState</code> 去获取并更新计数的值。</p><hr><p>调用 <code>function</code> 组件之前，我们需要初始化一些全局变量，这样我们可以在 <code>useState</code> 函数中引用。</p><p>同时也给 <code>fiber</code> 添加了一个 <code>hooks</code> 数组，目的是支持在相同组件内多次调用 <code>useState</code>。并且我们会持续追踪当前 <code>hook</code> 的索引。</p><hr><p>当我们有一个 <code>old hook</code>，并且我们没有初始化这个 <code>state</code>，那么就把 <code>old hook</code> 的 <code>state</code> 拷贝到 <code>new hook</code>。</p><p>当我们在 <code>fiber</code> 新增一个 <code>new hook</code>，那么一个一个增加 <code>hook</code> 的索引，然后返回这个 <code>state</code>。</p><hr><p><code>useState</code> 也应该返回一个可以更新 <code>state</code> 的函数，所以我们定义 <code>setState</code> 函数去接受一个行为。（在计数这个例子中，这个行为就是增加的函数）</p><p>我们把这个 <code>action</code> 追加到一个已经添加在 <code>hook</code> 的队列中。</p><p>然后我们在 <code>render</code> 函数中做一些相似的事儿，在工作的根节点中设置一个新的 <code>work</code> 作为下一个单元的 <code>work</code>，这样 <code>work</code> 循环可以开始一个新的 <code>render</code> 阶段。</p><hr><p>然而我们没有运行这个 <code>action</code>。</p><p>在下次渲染组件的时候再去做，从 <code>old hook</code> 的队列中把所有的 <code>action</code> 拿出来，然后在 <code>new hook</code> 状态中一个一个去执行，所以当我们返回 <code>state</code> 的时候，它就更新了。</p><hr><p>那这就是全部了，我们已经构建了自己的 <code>React</code>。</p><p>你可以在 <a href=https://codesandbox.io/s/didact-8-21ost><code>codesandbox</code></a> 👈 或者 <a href=https://github.com/pomber/didact><code>github</code></a> 👈 试试。</p><h2 id=结语>结语</h2><p>除了帮你理解<code>React</code>是怎么实现之外，其中一个目的是想让你更深入的理解 <code>React</code> 源码。这就是为什么我们经常用一些相同的变量名和函数名。</p><p>举个例子 🌰 ，如果在真实的 <code>React app</code> 中调试你的 <code>function</code> 组件，调用栈会显示：</p><ul><li><code>workLoop</code></li><li><code>performUnitOfWork</code></li><li><code>updateFunctionComponent</code></li></ul><p>我们没有包含很多 <code>React</code> 的特性和优化。例如，下面 👇 这些就和<code>React</code>中不一样。</p><ul><li><p>在 <code>Didact</code> 中，<code>render</code> 阶段遍历了整棵树 🌲。而 <code>React</code> 会根据一些策略跳过那些没有改变的子树 🌲</p></li><li><p>在 <code>commit</code> 阶段，我们同样遍历了整棵树 🌲。不过 <code>React</code> 用一个链表保存了受影响的 <code>fiber</code> 并且只会访问这些 <code>fiber</code></p></li><li><p>每次我们构建新的 <code>work</code> 时，我们为每个 <code>fiber</code> 都创建了一个新的 <code>object</code>。<code>React</code> 会回收这些之前树上的 <code>fiber</code></p></li><li><p>在 <code>render</code> 阶段，当 <code>Didact</code> 收到更新时，它会抛弃掉正在进行的 <code>work</code> 并且从 <code>root</code> 重新开始。<code>React</code> 用过期时间标记了每个更新， 并且用它们来决定哪个更新有更高的优先级。</p></li><li><p>其实还有更多&mldr;</p></li></ul><p>你也可以很容易的加一些特性：</p><ul><li>把 <code>object</code> 用在样式属性上</li><li><a href=https://github.com/pomber/didact/issues/11>扁平化子数组</a> 👈</li><li><code>useEffect</code> 的 <code>hook</code> 特性</li><li>通过 <code>key</code> 实现 <code>reconciliation</code></li></ul><p>如果你把这些或者其他特性加到 <code>Didact</code> 中，给 <a href=https://github.com/pomber/didact>GitHub 仓库</a> 👈 发送一个 <code>PR</code>，这样其他人就能看见了。</p><p>感谢阅读！</p><hr><ul class=pager><li class=previous><a href=/post/js/sentry/ data-toggle=tooltip data-placement=top title>&larr;
Previous Post</a></li><li class=next><a href=/post/brew-error/ data-toggle=tooltip data-placement=top title="Brew: Version value must be a string; got a NilClass">Next
Post &rarr;</a></li></ul></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5><a href=/tags/>FEATURED TAGS</a></h5><div class=tags><a href=/tags/qiankun title=qiankun>qiankun</a>
<a href=/tags/raspberrypi title=raspberrypi>raspberrypi</a>
<a href=/tags/ts title=ts>ts</a>
<a href=/tags/%E8%AF%91%E6%96%87 title=译文>译文</a></div></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li><a target=_blank href=https://github.com/chemistwang><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fab fa-github fa-stack-1x fa-inverse"></i></span></a></li><li><a href rel=alternate type=application/rss+xml title="Chemputer Blog"><span class="fa-stack fa-lg"><i class="fas fa-circle fa-stack-2x"></i>
<i class="fas fa-rss fa-stack-1x fa-inverse"></i></span></a></li></ul><p class="copyright text-muted">Copyright &copy; Chemputer Blog 2023<br><a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> by <a href=https://zhaohuabing.com>Huabing</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe></p></div></div></div></footer><script>function loadAsync(e,t){var s=document,o="script",n=s.createElement(o),i=s.getElementsByTagName(o)[0];n.src=e,t&&n.addEventListener("load",function(e){t(null,e)},!1),i.parentNode.insertBefore(n,i)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,a=$(_containerSelector),r=a.find("h1,h2,h3,h4,h5,h6");return $(e).html(""),r.each(function(){t=$(this).prop("tagName").toLowerCase(),o="#"+$(this).prop("id"),n=$(this).text(),i=$('<a href="'+o+'" rel="nofollow">'+n+"</a>"),s=$('<li class="'+t+'_nav"></li>').append(i),$(e).append(s)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script></body></html>